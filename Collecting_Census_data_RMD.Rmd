---
title: "Collecting_Census_Inc_Data"
author: "Fiona Edwardson"
date: "5/10/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(tidycensus)
library(sf)
library(tigris)
library(rmapshaper)
library(tmap)
library(areal)
library(leaflet)
library(dbplyr)
# install.packages("censusapi")
library(censusapi)
```

```{r putting in Census API key}

census_api_key("d1152bd242c2f6acbb41b8fc85fa9e9aa571a196", install = TRUE, overwrite = TRUE)

Sys.getenv("CENSUS_API_KEY")

readRenviron("~/.Renviron")
```

```{r confirm you're in the GISIII_Final_Project directory}

getwd()

```


# data: median household income

Data for all four cities

```{r pulling in the data}
chi_income2019 <- get_acs(geography = "tract", 
              year = 2019,
              variables = c(med_earn = "S2001_C01_002E"),
              state = "IL",
              county = "Cook",
              survey = "acs5",
              output = "wide",
              geometry = TRUE)

glimpse(chi_income2019)

char_income2019 <- get_acs(geography = "tract", 
              year = 2019,
              variables = c(med_earn = "S2001_C01_002E"),
              state = "SC",
              county = "Charleston",
              survey = "acs5",
              output = "wide",
              geometry = TRUE)

mpls_income2019 <- get_acs(geography = "tract", 
              year = 2019,
              variables = c(med_earn = "S2001_C01_002E"),
              state = "MN",
              county = "Hennepin",
              survey = "acs5",
              output = "wide",
              geometry = TRUE)

sd_income2019 <- get_acs(geography = "tract", 
              year = 2019,
              variables = c(med_earn = "S2001_C01_002E"),
              state = "CA",
              county = "San Diego",
              survey = "acs5",
              output = "wide",
              geometry = TRUE)


```


Now I need to pull in the city boundaries for each one:

```{r chicago boundaries}

chibounds = st_read("final_project/Boundaries - City(2)/geo_export_3d084884-b126-4daa-b908-1286d52a1e19.shp")

chibounds <- chibounds[0]
plot(chibounds[0])
plot(chi_income2019)
chi_inc <- chi_income2019["med_earn"]
plot(chi_inc)

```


```{r intersection}
st_crs(chi_inc)
st_crs(chibounds)

# setting NAD83 as the CRS
chibounds_CRS <- st_set_crs(chibounds, st_crs(chi_inc))
st_crs(chibounds_CRS)
chib_inc <- st_intersection(chi_inc, chibounds_CRS)

plot(chib_inc)
```


Now I just need to do this for the other cities: (it would also be cool to develop this into an algorithm...)

```{r mpls}

mpls_bounds <- st_read("final_project/mpls_bounds/16cdbbfa-ad10-493c-afaf-52b61f2e76e42020329-1-180h9ap.whbo.shp")
mpls_b <- mpls_bounds[0]
plot(mpls_b)

st_crs(chi_inc)
st_crs(chibounds)

# setting NAD83 as the CRS
chibounds_CRS <- st_set_crs(chibounds, st_crs(chi_inc))
st_crs(chibounds_CRS)
chib_inc <- st_intersection(chi_inc, chibounds_CRS)

plot(chib_inc)

```


```{r charleston}

charbounds <- st_read("final_project/charleston_Base_Zoning/Base_Zoning.shp")
char0 <- charbounds[0]
glimpse(char0)
char0dis <- aggregate(char0, by=char0$geometry, dissolve=TRUE) #by=char0$geometry
plot(char0dis)

char0dis2 <- st_union(char0dis)
plot(char0dis2)


plot(charbounds)
chibounds <- chibounds[0]
plot(chibounds[0])
plot(chi_income2019)
chi_inc <- chi_income2019["med_earn"]
plot(chi_inc)

```




Took longer than ideal to figure out what the dang variable name for the median earnings was called (the census data site is really not very well set up).


```{r subsetting for final df}

incdf15 <- data.frame("GEOID" = h_income2015$GEOID, "medearn" = h_income2015$med_earn)

incdf19 <- data.frame("GEOID" = h_income2019$GEOID, "medearn" = h_income2019$med_earn)

glimpse(incdf15)

```



## final data tables

We'll conclude with 2 separate tables, one for the index for 2015, one for the index for 2019.

```{r merging final dfs}

dem15 <- data.frame("GEOID" = dem15$GEOID, "pwhite" = dem15$pwhite)
dem19 <- data.frame("GEOID" = dem19$GEOID, "pwhite" = dem19$pwhite)

glimpse(pov15)
fdf15 <- left_join(pov15, dem15, by = "GEOID") 
fdf15 <- left_join(fdf15, incdf15, by = "GEOID")
fdf15 <- left_join(fdf15, dfhval15, by = "GEOID")

glimpse(fdf15)

fdf19 <- left_join(pov19, dem19, by = "GEOID") 
fdf19 <- left_join(fdf19, incdf19, by = "GEOID")
fdf19 <- left_join(fdf19, dfhval19, by = "GEOID")

glimpse(fdf19)

```

I need to do some final edits:
```{r choosing final variables}

ffdf15 <- data.frame("GEOID" = fdf15$GEOID, "pwhite" = fdf15$pwhite, "ppov" = fdf15$ppov, "medearn" = fdf15$medearn, "medHouse" = fdf15$medHouse)

glimpse(ffdf15)

ffdf19 <- data.frame("GEOID" = fdf19$GEOID, "pwhite" = fdf19$pwhite, "ppov" = fdf19$ppov, "medearn" = fdf19$medearn, "medHouse" = fdf19$medHouse)

glimpse(ffdf19)

```



## writing the dfs

I'm first going to make the folders in the directory that I want.

```{r saving the census data}
getwd()

write_csv(ffdf15, "Census_Data_For_Index/2015/Cen2015.csv")
write_csv(ffdf19, "Census_Data_For_Index/2019/Cen2019.csv")
```


# Making the Index:

```{r summary (find missing values)}

summary(ffdf15)

```

Ok, so we'll need to use na.rm = TRUE in some of our later operations. Let's ignore that for now.

## Standardizing variables

In order to combine variables into an index, we need to standardize them. We do this to get the variables onto the same scale. A common approach to standardizing a variable is to calculate its z-score. The z-score is a measure of distance from the mean, in this case the mean of all tracts in an area. So, after standardizing, the variables will have the same units, specifically units of standard deviations.

```{r calculating z scores}

ffdf15 %>%
  mutate(pwhite = (pwhite-mean(pwhite, na.rm=TRUE))/sd(pwhite, na.rm=TRUE)) %>%
  select(GEOID,pwhite) %>%
  summarize(Mean = mean(pwhite, na.rm = TRUE), SD = sd(pwhite, na.rm = TRUE)) 



```

```{r attempting to do this for all variables in the df}

cen15.std <- ffdf15 %>%
        mutate_at(~(scale(.) %>% as.vector(.)), .vars = vars(-c(GEOID)))

summary(cen15.std)

```

It seems to have worked, although I didn't take out the NA values! Yay!

Repeating for the 2019 data:

```{r 2019 index data}

cen19.std <- ffdf19 %>%
        mutate_at(~(scale(.) %>% as.vector(.)), .vars = vars(-c(GEOID)))

summary(cen19.std)

```

Moving forward, I'm just going to take the average of the variables. I'm going to focus on the census data for 2015 at the moment:

```{r adding avg col}

cen15.std <- cen15.std %>%
  mutate(DepInd15 = (pwhite+ppov+medearn+medHouse)/4)

glimpse(cen15.std)

# oops i already lied
cen19.std <- cen19.std %>%
  mutate(DepInd19 = (pwhite+ppov+medearn+medHouse)/4)

glimpse(cen19.std)
```

```{r selecting only index values}
Idf15 <- data.frame("GEOID" = cen15.std$GEOID, "I15" = cen15.std$DepInd15)
Idf19 <- data.frame("GEOID" = cen19.std$GEOID, "I19" = cen19.std$DepInd19)

Idf <- left_join(Idf15, Idf19, by = "GEOID")

print(Idf)

```

```{r putting in a change factor}

Idf <- mutate(Idf, Ichange = I19 - I15)

Idf <- data.frame("GEOID" = Idf$GEOID, "IDel" = Idf$Ichange)
plot(Idf$IDel)

```

Index done!

Writing the data as a csv file:

```{r}
write_csv(Idf, "Census_Data_For_Index/IndexVals.csv")
```
